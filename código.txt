

# -*- coding: utf-8 -*-
import os
import sys
import subprocess
import threading
import time
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import hashlib
import base64
import re
import logging
import paramiko
import ctypes
from PIL import Image, ImageTk
import tempfile
import webbrowser
import json
import urllib.request
import shutil
import socket
import glob
import traceback
from cryptography.hazmat.primitives import hashes, padding, hmac
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.exceptions import InvalidSignature, InvalidTag
from packaging import version

# Verificar se está rodando como executável empacotado (exe)
IS_EXE = getattr(sys, 'frozen', False)

# Versão do software
SOFTWARE_VERSION = "1.2.8"  # Atualizada para nova versão

# Oculta o console ao iniciar o .exe (Windows apenas)
if sys.platform.startswith('win') and IS_EXE:
    console_handle = ctypes.windll.kernel32.GetConsoleWindow()
    if console_handle:
        ctypes.windll.user32.ShowWindow(console_handle, 0)

# Configuração básica de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('ssh_tool')

# Filtros padrão (serão sobrescritos pela configuração)
DEFAULT_FILTER_USERS = ['root', 'zabbix', 'sshd', 'postfix', 'nscd', 'message+', 'usertra+', 'prod', 'fatura', 'logist', 'lp']
DEFAULT_FILTER_COMMANDS = [
    '(sd-pam)', 
    '-bash', 
    '/opt/microfocu', 
    '/opt/microfocus', 
    '/usr/lib/system', 
    'bash', 
    'pg /d/work/est2', 
    'ps aux', 
    'sh /app/scripts', 
    'sh /usr/bin/cha', 
    '/usr/lib/ssh/sf',
    '/opt/',
    'pg -f'
]

class AutoUpdater:
    """Sistema robusto de auto-atualização"""
    def __init__(self, gui_instance):
        self.gui = gui_instance
        self.current_version = SOFTWARE_VERSION
        self.github_token = "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"
        self.github_repo = "FranklinDeveloper/SSH"
        self.releases_url = f"https://api.github.com/repos/{self.github_repo}/releases/latest"
        self.update_in_progress = False

    def get_github_data(self, url):
        """Obtém dados da API do GitHub com autenticação"""
        headers = {
            "Authorization": f"Bearer {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        try:
            req = urllib.request.Request(url, headers=headers)
            with urllib.request.urlopen(req, timeout=15) as response:
                return json.loads(response.read().decode())
        except urllib.error.HTTPError as e:
            if e.code == 403:
                logger.error("Erro 403: Limite de requisições excedido no GitHub")
            elif e.code == 401:
                logger.error("Erro 401: Token de acesso inválido ou expirado")
            else:
                logger.error(f"Erro HTTP {e.code}: {e.reason}")
        except Exception as e:
            logger.error(f"Erro na conexão: {str(e)}")
        return None

    def is_update_available(self, release_data):
        """Verifica se há uma nova versão disponível"""
        try:
            latest_version = release_data["tag_name"].lstrip('v')
            return version.parse(latest_version) > version.parse(self.current_version), latest_version
        except Exception as e:
            logger.error(f"Erro ao comparar versões: {str(e)}")
            return False, None

    def download_asset(self, asset_url, save_path):
        """Baixa um asset do GitHub"""
        try:
            headers = {
                "Authorization": f"Bearer {self.github_token}",
                "Accept": "application/octet-stream"
            }
            
            req = urllib.request.Request(asset_url, headers=headers)
            with urllib.request.urlopen(req, timeout=30) as response:
                with open(save_path, 'wb') as out_file:
                    total_size = int(response.headers.get('content-length', 0))
                    downloaded = 0
                    chunk_size = 8192
                    
                    while True:
                        chunk = response.read(chunk_size)
                        if not chunk:
                            break
                        out_file.write(chunk)
                        downloaded += len(chunk)
                        
                        # Atualizar progresso (opcional)
                        if total_size > 0:
                            progress = (downloaded / total_size) * 100
                            self.gui.update_progress(progress, f"Baixando: {progress:.1f}%")
            
            return True
        except Exception as e:
            logger.error(f"Erro no download: {str(e)}")
            return False

    def verify_file_integrity(self, file_path, expected_hash):
        """Verifica a integridade do arquivo com SHA-256"""
        try:
            sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                while chunk := f.read(8192):
                    sha256.update(chunk)
                    
            return sha256.hexdigest().lower() == expected_hash.lower()
        except Exception as e:
            logger.error(f"Erro na verificação: {str(e)}")
            return False

    def apply_update(self, temp_file):
        """Substitui o executável atual pela nova versão"""
        try:
            current_exe = sys.executable
            backup_exe = current_exe + ".bak"
            
            # Cria backup da versão atual
            if os.path.exists(backup_exe):
                os.remove(backup_exe)
            shutil.copy(current_exe, backup_exe)
            
            # Substitui o executável
            shutil.move(temp_file, current_exe)
            
            return True
        except Exception as e:
            logger.error(f"Erro na aplicação da atualização: {str(e)}")
            # Tenta restaurar o backup em caso de erro
            if os.path.exists(backup_exe):
                try:
                    shutil.copy(backup_exe, current_exe)
                except Exception:
                    pass
            return False

    def restart_application(self):
        """Reinicia a aplicação"""
        if sys.platform.startswith('win'):
            subprocess.Popen([sys.executable] + sys.argv, creationflags=subprocess.CREATE_NO_WINDOW)
        else:
            subprocess.Popen([sys.executable] + sys.argv)
        sys.exit()

    def check_and_apply_update(self):
        """Executa todo o processo de atualização"""
        if self.update_in_progress:
            return
            
        self.update_in_progress = True
        self.gui.update_progress(0, "Verificando atualizações...")
        
        # Obtém informações da última release
        release_data = self.get_github_data(self.releases_url)
        if not release_data:
            self.gui.update_progress(0, "Falha ao verificar atualizações")
            self.update_in_progress = False
            return
        
        # Verifica se há atualização disponível
        update_available, latest_version = self.is_update_available(release_data)
        if not update_available:
            self.gui.update_progress(100, "Você já tem a versão mais recente")
            self.update_in_progress = False
            return
        
        self.gui.update_progress(10, f"Nova versão encontrada: {latest_version}")
        
        # Encontra o asset correto para download
        asset = next((a for a in release_data["assets"] 
                     if a["name"].startswith("GerenciadorSSH") and a["name"].endswith(".exe")), None)
        
        if not asset:
            self.gui.update_progress(0, "Nenhum asset compatível encontrado")
            self.update_in_progress = False
            return
        
        # Encontra o hash correspondente
        hash_asset = next((a for a in release_data["assets"] 
                         if a["name"] == asset["name"] + ".sha256"), None)
        
        if not hash_asset:
            self.gui.update_progress(0, "Hash de verificação não encontrado")
            self.update_in_progress = False
            return
        
        # Cria diretório temporário
        temp_dir = tempfile.mkdtemp()
        exe_path = os.path.join(temp_dir, asset["name"])
        hash_path = os.path.join(temp_dir, hash_asset["name"])
        
        # Baixa o executável
        self.gui.update_progress(20, f"Baixando {asset['name']}...")
        if not self.download_asset(asset["url"], exe_path):
            self.gui.update_progress(0, "Falha no download da atualização")
            shutil.rmtree(temp_dir, ignore_errors=True)
            self.update_in_progress = False
            return
        
        # Baixa o hash
        self.gui.update_progress(60, "Baixando verificação de integridade...")
        if not self.download_asset(hash_asset["url"], hash_path):
            self.gui.update_progress(0, "Falha ao baixar verificação de integridade")
            shutil.rmtree(temp_dir, ignore_errors=True)
            self.update_in_progress = False
            return
        
        # Lê o hash esperado
        try:
            with open(hash_path, 'r') as f:
                expected_hash = f.read().strip()
        except Exception as e:
            self.gui.update_progress(0, f"Erro ao ler hash: {str(e)}")
            shutil.rmtree(temp_dir, ignore_errors=True)
            self.update_in_progress = False
            return
        
        # Verifica integridade
        self.gui.update_progress(80, "Verificando integridade do arquivo...")
        if not self.verify_file_integrity(exe_path, expected_hash):
            self.gui.update_progress(0, "Falha na verificação de integridade!")
            shutil.rmtree(temp_dir, ignore_errors=True)
            self.update_in_progress = False
            return
        
        # Aplica a atualização
        self.gui.update_progress(90, "Aplicando atualização...")
        if self.apply_update(exe_path):
            self.gui.update_progress(100, "Atualização aplicada com sucesso! Reiniciando...")
            time.sleep(2)
            self.restart_application()
        else:
            self.gui.update_progress(0, "Falha ao aplicar a atualização")
        
        shutil.rmtree(temp_dir, ignore_errors=True)
        self.update_in_progress = False

class InteractiveHostKeyPolicy(paramiko.MissingHostKeyPolicy):
    """Política interativa para verificação de host keys"""
    def __init__(self, root, port=22):
        self.root = root
        self.port = port
        super().__init__()
    
    def missing_host_key(self, client, hostname, key):
        """Trata chaves de host desconhecidas"""
        fp = hashlib.sha256(key.asbytes()).digest()
        fp_base64 = base64.b64encode(fp).rstrip(b'=').decode('ascii')
        
        top = tk.Toplevel(self.root)
        top.title("Verificação de Segurança")
        top.geometry("600x250")
        top.resizable(False, False)
        top.transient(self.root)
        top.grab_set()
        
        frame = ttk.Frame(top, padding="10")
        frame.pack(fill=tk.BOTH, expand=True)
        
        msg = (
            f"ATENÇÃO: Host desconhecido '{hostname}'!\n\n"
            f"Fingerprint (SHA256): {fp_base64}\n\n"
            "Deseja confiar neste host?"
        )
        ttk.Label(frame, text=msg).pack(pady=10)
        
        self.remember_var = tk.BooleanVar(value=True)
        save_check = ttk.Checkbutton(
            frame, 
            text="Lembrar este host permanentemente",
            variable=self.remember_var
        )
        save_check.pack(pady=5)
        
        user_response = None
        
        def handle_response(response):
            nonlocal user_response
            user_response = response
            top.destroy()
        
        btn_frame = ttk.Frame(frame)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="Sim", command=lambda: handle_response(True)).pack(side=tk.LEFT, padx=10)
        ttk.Button(btn_frame, text="Não", command=lambda: handle_response(False)).pack(side=tk.LEFT, padx=10)
        
        top.update_idletasks()
        width = top.winfo_width()
        height = top.winfo_height()
        x = (top.winfo_screenwidth() // 2) - (width // 2)
        y = (top.winfo_screenheight() // 2) - (height // 2)
        top.geometry(f"{width}x{height}+{x}+{y}")
        
        self.root.wait_window(top)
        
        if not user_response:
            raise paramiko.SSHException(f"Host {hostname} rejeitado pelo usuário")
        
        client._host_keys.add(hostname, key.get_name(), key)
        
        if self.remember_var.get():
            try:
                known_hosts = os.path.expanduser("~/.ssh/known_hosts")
                os.makedirs(os.path.dirname(known_hosts), exist_ok=True)
                
                if self.port != 22:
                    host_key = f"[{hostname}]:{self.port}"
                else:
                    host_key = hostname
                
                with open(known_hosts, 'a') as f:
                    f.write(f"{host_key} {key.get_name()} {key.get_base64()}\n")
                
                messagebox.showinfo("Sucesso", 
                    f"Host {host_key} adicionado permanentemente ao arquivo known_hosts")
            except Exception as e:
                messagebox.showerror("Erro", 
                    f"Falha ao salvar no known_hosts: {str(e)}")

class SSHClientGUI:
    """Interface gráfica para cliente SSH"""
    def __init__(self, root):
        self.root = root
        self.root.title(f"Gerenciador SSH Avançado v{SOFTWARE_VERSION}")
        self.root.geometry("950x600")
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)

        self.logo_photo = None
        self.temp_ico_file = None
        self.load_application_icon()
        
        # Inicializa o sistema de auto-atualização
        self.updater = AutoUpdater(self)
        
        self.all_processes = []
        self.host_history = []
        self.admin_config_file = os.path.join(os.path.expanduser("~"), ".ssh_tool_config")
        self.DEFAULT_UPDATE_URL = "https://raw.githubusercontent.com/seu-usuario/seu-repositorio/main/version.json"
        self.admin_config = self.load_admin_config()
        self.permanent_filter = {
            'users': self.admin_config.get('permanent_filter_users', DEFAULT_FILTER_USERS),
            'commands': self.admin_config.get('permanent_filter_commands', DEFAULT_FILTER_COMMANDS)
        }
        
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TNotebook.Tab', background="#626669", foreground='white')
        self.style.map('TNotebook.Tab', background=[('selected', "#42a707")])
        self.style.configure('.', font=('Segoe UI', 10))
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TLabel', background='#f0f0f0')
        self.style.configure('TLabelframe', background='#f0f0f0')
        self.style.configure('TLabelframe.Label', background='#f0f0f0')
        self.style.configure('Treeview', rowheight=25, font=('Consolas', 9))
        self.style.map('Treeview', background=[('selected', '#0078d7')])
        self.style.configure('Treeview.Heading', font=('Segoe UI', 9, 'bold'))
        self.style.configure('TButton', font=('Segoe UI', 9))
        self.style.configure('Red.TButton', foreground='white', background='#d9534f')
        self.style.map('Red.TButton', 
                      background=[('active', '#c9302c'), ('disabled', '#f5c6cb')])
        self.style.configure('Green.TButton', foreground='white', background='#5cb85c')
        self.style.map('Green.TButton', 
                      background=[('active', '#4cae4c'), ('disabled', '#c3e6cb')])
        self.style.configure('Blue.TButton', foreground='white', background='#007bff')
        self.style.map('Blue.TButton', 
                      background=[('active', '#0069d9'), ('disabled', '#b3d7ff')])
        
        main_frame = ttk.Frame(root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.client = None
        self.shell = None
        self.current_host = None
        self.stop_receiver = threading.Event()
        self.receiver_thread = None
        self.running = True
        self.show_password = False
        self.caps_lock_warning_shown = False
        
        conn_frame = ttk.LabelFrame(main_frame, text="Configuração de Conexão")
        conn_frame.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(conn_frame, text="Host:").grid(row=0, column=0, padx=3, pady=2, sticky=tk.W)
        self.host_var = tk.StringVar(value="mg01.grp.local")
        self.host_combo = ttk.Combobox(conn_frame, textvariable=self.host_var, width=15)
        self.host_combo.grid(row=0, column=1, padx=3, pady=2, sticky=tk.W)
        self.host_combo['values'] = self.load_host_history()
        self.host_combo.bind("<<ComboboxSelected>>", self.on_host_selected)
        self.host_combo.bind("<Return>", lambda event: self.connect())
        
        ttk.Label(conn_frame, text="Usuário:").grid(row=0, column=2, padx=(8,3), pady=2, sticky=tk.W)
        self.user_var = tk.StringVar(value="prod")
        user_entry = ttk.Entry(conn_frame, textvariable=self.user_var, width=10)
        user_entry.grid(row=0, column=3, padx=3, pady=2, sticky=tk.W)
        user_entry.bind("<Return>", lambda event: self.connect())
        
        ttk.Label(conn_frame, text="Senha:").grid(row=0, column=4, padx=(8,3), pady=2, sticky=tk.W)
        
        password_frame = ttk.Frame(conn_frame)
        password_frame.grid(row=0, column=5, padx=3, pady=2, sticky=tk.W)
        
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(password_frame, textvariable=self.password_var, show="*", width=10)
        self.password_entry.pack(side=tk.LEFT)
        self.password_entry.bind("<Return>", lambda event: self.connect())
        
        self.eye_button = ttk.Button(
            password_frame, 
            text="\U0001F441",  # Olho Unicode
            width=2, 
            command=self.toggle_password_visibility
        )
        self.eye_button.pack(side=tk.LEFT, padx=(2,0))
        self.password_entry.bind("<FocusIn>", self.on_password_focus_in)
        self.password_entry.bind("<KeyRelease>", self.on_password_key_release)
        
        ttk.Label(conn_frame, text="Porta:").grid(row=0, column=6, padx=(8,3), pady=2, sticky=tk.W)
        self.port_var = tk.StringVar(value="22")
        port_entry = ttk.Entry(conn_frame, textvariable=self.port_var, width=4)
        port_entry.grid(row=0, column=7, padx=3, pady=2, sticky=tk.W)
        port_entry.bind("<Return>", lambda event: self.connect())
        
        btn_frame = ttk.Frame(conn_frame)
        btn_frame.grid(row=0, column=8, padx=(10,3), pady=2, sticky=tk.E)
        
        self.connect_btn = ttk.Button(btn_frame, text="Conectar", 
                                     command=self.connect, style='Green.TButton', width=9)
        self.connect_btn.pack(side=tk.LEFT, padx=2)
        
        self.disconnect_btn = ttk.Button(btn_frame, text="Desconectar", 
                                        command=self.disconnect, state=tk.DISABLED,
                                        style='Red.TButton', width=12)
        self.disconnect_btn.pack(side=tk.LEFT, padx=2)
        
        self.admin_btn = ttk.Button(
            btn_frame, 
            text="Administrador",
            command=self.show_admin_dialog,
            style='Blue.TButton',
            width=14
        )
        self.admin_btn.pack(side=tk.LEFT, padx=2)
        
        help_btn = ttk.Button(
            btn_frame, 
            text="Ajuda?",
            command=self.show_help,
            width=6
        )
        help_btn.pack(side=tk.LEFT, padx=2)
        
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 5))
        
        # Aba Derrubar Conf
        pid_frame = ttk.Frame(self.notebook)
        self.notebook.add(pid_frame, text=" Derrubar Conf ")
        top_frame = ttk.Frame(pid_frame)
        top_frame.pack(fill=tk.X, padx=5, pady=2)
        action_frame = ttk.Frame(top_frame)
        action_frame.pack(side=tk.LEFT, padx=(0,5))
        list_btn = ttk.Button(action_frame, text="Listar Processos", 
                  command=self.list_processes, width=15)
        list_btn.pack(side=tk.TOP, pady=1)
        refresh_btn = ttk.Button(action_frame, text="Atualizar Lista", 
                  command=self.list_processes, width=15)
        refresh_btn.pack(side=tk.TOP, pady=1)
        filter_frame = ttk.LabelFrame(top_frame, text="Filtros")
        filter_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=0)
        ttk.Label(filter_frame, text="Usuário:").pack(side=tk.LEFT, padx=(5,2))
        self.user_filter_var = tk.StringVar()
        user_filter_entry = ttk.Entry(filter_frame, textvariable=self.user_filter_var, width=10)
        user_filter_entry.pack(side=tk.LEFT, padx=(0,3))
        user_filter_entry.bind("<Return>", lambda event: self.apply_filters())
        ttk.Label(filter_frame, text="PID:").pack(side=tk.LEFT, padx=(5,2))
        self.pid_filter_var = tk.StringVar()
        pid_filter_entry = ttk.Entry(filter_frame, textvariable=self.pid_filter_var, width=6)
        pid_filter_entry.pack(side=tk.LEFT, padx=(0,3))
        pid_filter_entry.bind("<Return>", lambda event: self.apply_filters())
        ttk.Label(filter_frame, text="Command:").pack(side=tk.LEFT, padx=(5,2))
        self.cmd_filter_var = tk.StringVar()
        cmd_filter_entry = ttk.Entry(filter_frame, textvariable=self.cmd_filter_var, width=15)
        cmd_filter_entry.pack(side=tk.LEFT, padx=(0,3))
        cmd_filter_entry.bind("<Return>", lambda event: self.apply_filters())
        apply_btn = ttk.Button(filter_frame, text="Aplicar Filtros", 
                  command=self.apply_filters, width=12)
        apply_btn.pack(side=tk.LEFT, padx=2)
        clear_btn = ttk.Button(filter_frame, text="Limpar Filtros", 
                  command=self.clear_filters, width=12)
        clear_btn.pack(side=tk.LEFT)
        input_frame = ttk.LabelFrame(pid_frame, text="Seleção de PIDs")
        input_frame.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(input_frame, 
                 text="Selecione PIDs na tabela ou digite manualmente (separados por espaço):").pack(anchor=tk.W, padx=5, pady=(2,0))
        self.pids_var = tk.StringVar()
        self.pids_entry = ttk.Entry(input_frame, textvariable=self.pids_var)
        self.pids_entry.pack(fill=tk.X, padx=5, pady=2)
        self.pids_entry.bind("<Return>", lambda event: self.kill_pids())
        btn_action_frame = ttk.Frame(input_frame)
        btn_action_frame.pack(fill=tk.X, pady=(0,2))
        self.kill_button = ttk.Button(
            btn_action_frame, 
            text="Derrubar PIDs Selecionados", 
            command=self.kill_pids, 
            style='Red.TButton',
            width=20
        )
        self.kill_button.pack(side=tk.LEFT, padx=2)
        self.clear_button = ttk.Button(
            btn_action_frame, 
            text="Limpar Seleção",
            command=lambda: self.pids_var.set(""),
            width=15
        )
        self.clear_button.pack(side=tk.LEFT, padx=2)
        tree_frame = ttk.Frame(pid_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0,2))
        columns = ('user', 'pid', 'idle', 'command')
        self.process_tree = ttk.Treeview(
            tree_frame, columns=columns, show='headings', selectmode='extended'
        )
        col_widths = [100, 70, 70, 380]
        for idx, col in enumerate(columns):
            self.process_tree.heading(
                col, 
                text=col.upper(), 
                anchor=tk.W,
                command=lambda c=col: self.treeview_sort_column(self.process_tree, c, False)
            )
            self.process_tree.column(col, width=col_widths[idx], anchor=tk.W)
        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.process_tree.yview)
        self.process_tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.process_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.process_tree.bind('<<TreeviewSelect>>', self.on_pid_select)
        
        # Aba Derrubar Matrícula e Romaneio
        matricula_frame = ttk.Frame(self.notebook)
        self.notebook.add(matricula_frame, text=" Derrubar Matrícula e Romaneio ")
        input_frame = ttk.LabelFrame(matricula_frame, text="Consulta de PID")
        input_frame.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(input_frame, text="Matrícula ou Romaneio:").pack(side=tk.LEFT, padx=(5,2))
        self.matricula_var = tk.StringVar()
        matricula_entry = ttk.Entry(input_frame, textvariable=self.matricula_var, width=15)
        matricula_entry.pack(side=tk.LEFT, padx=(0,5))
        matricula_entry.bind("<Return>", lambda event: self.consultar_matricula())
        self.consultar_matricula_btn = ttk.Button(
            input_frame, 
            text="Consultar", 
            command=self.consultar_matricula,
            width=10
        )
        self.consultar_matricula_btn.pack(side=tk.LEFT)
        status_frame = ttk.LabelFrame(matricula_frame, text="Status da Operação")
        status_frame.pack(fill=tk.X, padx=5, pady=2)
        self.matricula_status_var = tk.StringVar(value="Aguardando operação...")
        ttk.Label(
            status_frame, 
            textvariable=self.matricula_status_var,
            font=('Segoe UI', 9, 'italic'),
            wraplength=900
        ).pack(fill=tk.X, padx=5, pady=2)
        pid_select_frame = ttk.LabelFrame(matricula_frame, text="Seleção de PIDs")
        pid_select_frame.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(pid_select_frame, 
                 text="Selecione PIDs na tabela ou digite manualmente (separados por espaço):").pack(anchor=tk.W, padx=5, pady=(2,0))
        self.matricula_pids_var = tk.StringVar()
        self.matricula_pids_entry = ttk.Entry(pid_select_frame, textvariable=self.matricula_pids_var)
        self.matricula_pids_entry.pack(fill=tk.X, padx=5, pady=2)
        self.matricula_pids_entry.bind("<Return>", lambda event: self.derrubar_pid_selecionado())
        btn_action_frame = ttk.Frame(pid_select_frame)
        btn_action_frame.pack(fill=tk.X, pady=(0,2))
        self.derrubar_pid_selecionado_btn = ttk.Button(
            btn_action_frame, 
            text="Derrubar PIDs Selecionados", 
            command=self.derrubar_pid_selecionado,
            style='Red.TButton',
            width=20
        )
        self.derrubar_pid_selecionado_btn.pack(side=tk.LEFT, padx=2)
        self.clear_matricula_button = ttk.Button(
            btn_action_frame, 
            text="Limpar Seleção",
            command=lambda: self.matricula_pids_var.set(""),
            width=15
        )
        self.clear_matricula_button.pack(side=tk.LEFT, padx=2)
        result_frame = ttk.LabelFrame(matricula_frame, text="Resultados da Consulta")
        result_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        columns = ('user', 'pid', 'name')
        self.result_tree = ttk.Treeview(
            result_frame, 
            columns=columns, 
            show='headings',
            selectmode='extended'
        )
        col_widths = [80, 60, 400]
        for idx, col in enumerate(columns):
            self.result_tree.heading(
                col, 
                text=col.upper(), 
                anchor=tk.W,
                command=lambda c=col: self.treeview_sort_column(self.result_tree, c, False)
            )
            self.result_tree.column(col, width=col_widths[idx], anchor=tk.W)
        scrollbar = ttk.Scrollbar(result_frame, orient=tk.VERTICAL, command=self.result_tree.yview)
        self.result_tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.result_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.result_tree.bind('<<TreeviewSelect>>', self.on_matricula_pid_select)
        
        # Aba Consultar Tela
        tela_frame = ttk.Frame(self.notebook)
        self.notebook.add(tela_frame, text=" Consultar Tela ")
        input_frame_tela = ttk.LabelFrame(tela_frame, text="Consulta de PID")
        input_frame_tela.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(input_frame_tela, text="Tela:").pack(side=tk.LEFT, padx=(5,2))
        self.tela_var = tk.StringVar(value="*")
        tela_entry = ttk.Entry(input_frame_tela, textvariable=self.tela_var, width=15)
        tela_entry.pack(side=tk.LEFT, padx=(0,5))
        tela_entry.bind("<Return>", lambda event: self.consultar_tela())
        self.consultar_tela_btn = ttk.Button(
            input_frame_tela, 
            text="Consultar Tela", 
            command=self.consultar_tela,
            width=13
        )
        self.consultar_tela_btn.pack(side=tk.LEFT)
        status_frame_tela = ttk.LabelFrame(tela_frame, text="Status da Operação")
        status_frame_tela.pack(fill=tk.X, padx=5, pady=2)
        self.tela_status_var = tk.StringVar(value="Aguardando operação...")
        ttk.Label(
            status_frame_tela, 
            textvariable=self.tela_status_var,
            font=('Segoe UI', 9, 'italic'),
            wraplength=900
        ).pack(fill=tk.X, padx=5, pady=2)
        pid_select_frame_tela = ttk.LabelFrame(tela_frame, text="Seleção de PIDs")
        pid_select_frame_tela.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(pid_select_frame_tela, 
                 text="Selecione PIDs na tabela ou digite manualmente (separados por espaço):").pack(anchor=tk.W, padx=5, pady=(2,0))
        self.tela_pids_var = tk.StringVar()
        self.tela_pids_entry = ttk.Entry(pid_select_frame_tela, textvariable=self.tela_pids_var)
        self.tela_pids_entry.pack(fill=tk.X, padx=5, pady=2)
        self.tela_pids_entry.bind("<Return>", lambda event: self.derrubar_pid_tela())
        btn_action_frame_tela = ttk.Frame(pid_select_frame_tela)
        btn_action_frame_tela.pack(fill=tk.X, pady=(0,2))
        self.derrubar_pid_tela_btn = ttk.Button(
            btn_action_frame_tela, 
            text="Derrubar PIDs Selecionados", 
            command=self.derrubar_pid_tela,
            style='Red.TButton',
            width=20
        )
        self.derrubar_pid_tela_btn.pack(side=tk.LEFT, padx=2)
        self.clear_tela_button = ttk.Button(
            btn_action_frame_tela, 
            text="Limpar Seleção",
            command=lambda: self.tela_pids_var.set(""),
            width=15
        )
        self.clear_tela_button.pack(side=tk.LEFT, padx=2)
        result_frame_tela = ttk.LabelFrame(tela_frame, text="Resultados da Consulta")
        result_frame_tela.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        columns = ('user', 'pid', 'name')
        self.tela_tree = ttk.Treeview(
            result_frame_tela, 
            columns=columns, 
            show='headings',
            selectmode='extended'
        )
        col_widths = [80, 60, 400]
        for idx, col in enumerate(columns):
            self.tela_tree.heading(
                col, 
                text=col.upper(), 
                anchor=tk.W,
                command=lambda c=col: self.treeview_sort_column(self.tela_tree, c, False)
            )
            self.tela_tree.column(col, width=col_widths[idx], anchor=tk.W)
        scrollbar_tela = ttk.Scrollbar(result_frame_tela, orient=tk.VERTICAL, command=self.tela_tree.yview)
        self.tela_tree.configure(yscroll=scrollbar_tela.set)
        scrollbar_tela.pack(side=tk.RIGHT, fill=tk.Y)
        self.tela_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.tela_tree.bind('<<TreeviewSelect>>', self.on_tela_pid_select)
        
        # Aba Terminal Interativo
        terminal_frame = ttk.Frame(self.notebook)
        self.notebook.add(terminal_frame, text=" Terminal Interativo ")
        self.output_text = scrolledtext.ScrolledText(
            terminal_frame, wrap=tk.WORD, bg='#1e1e1e', fg='#d4d4d4', 
            insertbackground='white', font=('Consolas', 10)
        )
        self.output_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        self.output_text.config(state=tk.DISABLED)
        cmd_frame = ttk.Frame(terminal_frame)
        cmd_frame.pack(fill=tk.X, padx=5, pady=(0,2))
        ttk.Label(cmd_frame, text="Comando:").pack(side=tk.LEFT, padx=(0,5))
        self.cmd_var = tk.StringVar()
        self.cmd_entry = ttk.Entry(cmd_frame, textvariable=self.cmd_var, width=40)
        self.cmd_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,5))
        self.cmd_entry.bind("<Return>", self.send_command)
        send_btn = ttk.Button(cmd_frame, text="Enviar", command=self.send_command)
        send_btn.pack(side=tk.LEFT)
        
        # Aba Executar Comandos
        commands_frame = ttk.Frame(self.notebook)
        self.notebook.add(commands_frame, text=" Executar Comandos ")
        cmd_input_frame = ttk.Frame(commands_frame)
        cmd_input_frame.pack(fill=tk.X, padx=5, pady=2)
        ttk.Label(cmd_input_frame, text="Comandos (um por linha):").pack(anchor=tk.W, pady=(0,2))
        self.commands_text = scrolledtext.ScrolledText(cmd_input_frame, height=6, font=('Consolas', 9))
        self.commands_text.pack(fill=tk.X, pady=(0,2))
        self.commands_text.insert(tk.END, "ls -la\necho \"Teste SSH\"\nwhoami")
        exec_btn = ttk.Button(
            cmd_input_frame, text="Executar Comandos", command=self.execute_commands
        )
        exec_btn.pack(anchor=tk.E, pady=2)
        result_frame = ttk.Frame(commands_frame)
        result_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0,2))
        ttk.Label(result_frame, text="Resultados:", font=("Segoe UI", 9, "bold")).pack(anchor=tk.W)
        self.result_text = scrolledtext.ScrolledText(
            result_frame, wrap=tk.WORD, bg='#1e1e1e', fg='#d4d4d4', 
            font=('Consolas', 10), state=tk.DISABLED
        )
        self.result_text.pack(fill=tk.BOTH, expand=True)
        self.password_entry.focus_set()
        
        # Rodapé
        footer_frame = ttk.Frame(root, relief=tk.SUNKEN, padding=(5, 3))
        footer_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.connection_status = tk.StringVar(value="Status: Desconectado")
        status_label = ttk.Label(footer_frame, textvariable=self.connection_status)
        status_label.pack(side=tk.LEFT, padx=5)
        copyright_frame = ttk.Frame(footer_frame)
        copyright_frame.pack(side=tk.RIGHT, padx=5)
        ttk.Label(copyright_frame, text=f"© 2024 Franklin Tadeu v{SOFTWARE_VERSION}").pack(side=tk.LEFT)
        link_label = ttk.Label(
            copyright_frame, 
            text="LinkedIn", 
            foreground="blue", 
            cursor="hand2"
        )
        link_label.pack(side=tk.LEFT, padx=(5, 0))
        link_label.bind("<Button-1>", lambda e: webbrowser.open("https://www.linkedin.com/in/franklintadeu/"))
        contact_frame = ttk.Frame(footer_frame)
        contact_frame.pack(side=tk.RIGHT, padx=5)
        ttk.Label(contact_frame, text="Contato:").pack(side=tk.LEFT, padx=(5,0))
        whatsapp_label = ttk.Label(
            contact_frame, 
            text="31 99363-9500", 
            foreground="blue", 
            cursor="hand2"
        )
        whatsapp_label.pack(side=tk.LEFT, padx=(0,5))
        whatsapp_label.bind("<Button-1>", lambda e: webbrowser.open("https://wa.me/5531993639500"))
        update_btn = ttk.Button(
            footer_frame, 
            text="Verificar Atualizações",
            command=self.check_for_updates
        )
        update_btn.pack(side=tk.RIGHT, padx=5)
        root.protocol("WM_DELETE_WINDOW", self.safe_close)

        self.capturing_matricula = False
        self.matricula_output = ""
        self.capturing_tela = False
        self.tela_output = ""
        self.setup_treeview_bindings()

    def update_progress(self, value, message):
        """Atualiza a barra de progresso (se disponível)"""
        # Esta função será implementada se houver uma UI de progresso
        # Por enquanto, vamos logar apenas
        logger.info(f"{message} ({value}%)")

    def check_for_updates(self):
        """Inicia a verificação de atualizações em segundo plano"""
        threading.Thread(target=self.updater.check_and_apply_update, daemon=True).start()

    @classmethod
    def generate_salt(cls):
        hostname = socket.gethostname().encode()
        return hashlib.sha256(hostname).digest()[:16]

    @staticmethod
    def get_master_key():
        parts = [
            "c0mpl3xP@ss_",
            "w1thS0m3R@nd0m",
            "5tringAndNumb3rs",
            "!@#$%^&*()"
        ]
        return "".join(parts)

    @classmethod
    def derive_key(cls, salt=None):
        if salt is None:
            salt = cls.generate_salt()
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=64,
            salt=salt,
            iterations=100000,
            backend=default_backend
        )
        return kdf.derive(cls.get_master_key().encode())

    @classmethod
    def encrypt_data(cls, plaintext):
        try:
            salt = cls.generate_salt()
            key = cls.derive_key(salt)
            aes_key = key[:32]
            hmac_key = key[32:]
            iv = os.urandom(16)
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
            encryptor = cipher.encryptor()
            padder = padding.PKCS7(128).padder()
            padded_data = padder.update(plaintext.encode()) + padder.finalize()
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()
            h = hmac.HMAC(hmac_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + ciphertext)
            tag = h.finalize()
            return base64.b64encode(salt + iv + ciphertext + tag).decode()
        except Exception as e:
            logger.error(f"Encryption error: {e}")
            return plaintext

    @classmethod
    def decrypt_data(cls, ciphertext_b64):
        try:
            data = base64.b64decode(ciphertext_b64)
            if len(data) < (16 + 16 + 32):
                logger.error("Decryption error: Data too short")
                return ciphertext_b64
            salt = data[:16]
            iv = data[16:32]
            ciphertext = data[32:-32]
            tag = data[-32:]
            key = cls.derive_key(salt)
            aes_key = key[:32]
            hmac_key = key[32:]
            h = hmac.HMAC(hmac_key, hashes.SHA256(), backend=default_backend())
            h.update(iv + ciphertext)
            try:
                h.verify(tag)
            except (InvalidTag, InvalidSignature) as e:
                logger.error(f"HMAC verification failed: {e}")
                return ciphertext_b64
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            unpadder = padding.PKCS7(128).unpadder()
            try:
                plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
                return plaintext.decode()
            except ValueError as e:
                logger.error(f"Padding error: {e}")
                return padded_plaintext.decode(errors='ignore')
        except Exception as e:
            logger.error(f"Decryption error: {e}")
            return ciphertext_b64

    def load_admin_config(self):
        MASTER_PASSWORD = "Carro@#356074"
        master_password_hash = hashlib.sha256(MASTER_PASSWORD.encode()).hexdigest()
        default_config = {
            'admin_password': self.encrypt_data('admin'),
            'master_password_hash': master_password_hash,
            'update_url': self.DEFAULT_UPDATE_URL,
            'permanent_filter_users': DEFAULT_FILTER_USERS,
            'permanent_filter_commands': DEFAULT_FILTER_COMMANDS
        }
        config_path = self.admin_config_file
        if not os.path.exists(config_path):
            return default_config
        try:
            with open(config_path, 'r') as f:
                config = json.load(f)
            for key, value in default_config.items():
                if key not in config:
                    config[key] = value
            return config
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return default_config

    def save_admin_config(self, config):
        config_to_save = config.copy()
        if 'admin_password' in config_to_save and not re.match(r'^[A-Za-z0-9+/]+={0,2}$', config_to_save['admin_password']):
            config_to_save['admin_password'] = self.encrypt_data(config_to_save['admin_password'])
        try:
            with open(self.admin_config_file, 'w') as f:
                json.dump(config_to_save, f)
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False

    def load_application_icon(self):
        icon_found = False
        base_paths = []
        if getattr(sys, 'frozen', False):
            base_paths.append(sys._MEIPASS)
        base_paths.append(os.path.dirname(os.path.abspath(__file__)))
        base_paths.append(os.getcwd())
        icon_filenames = [
            "logoicogrupoprofarma.ico",
            "logoicogrupoprofarma.png",
            "logo.ico",
            "icon.ico",
            "app_icon.ico",
            "logo.png",
            "icon.png"
        ]
        for base_path in base_paths:
            for icon_name in icon_filenames:
                try:
                    image_path = os.path.join(base_path, icon_name)
                    if os.path.exists(image_path):
                        if icon_name.endswith('.ico'):
                            self.root.iconbitmap(image_path)
                            icon_found = True
                            logger.info(f"Ícone carregado: {image_path}")
                            break
                        else:
                            img_icon = Image.open(image_path)
                            img_icon = img_icon.resize((32, 32), Image.LANCZOS)
                            with tempfile.NamedTemporaryFile(delete=False, suffix='.ico') as temp_ico:
                                img_icon.save(temp_ico.name, format='ICO')
                                self.temp_ico_file = temp_ico.name
                            self.root.iconbitmap(self.temp_ico_file)
                            icon_found = True
                            logger.info(f"Ícone convertido e carregado: {image_path}")
                            break
                except Exception as e:
                    logger.error(f"Erro ao carregar ícone: {str(e)}")
                    continue
            if icon_found:
                break
        if not icon_found:
            try:
                self.root.iconbitmap(default='')
                logger.warning("Usando ícone padrão do sistema")
            except Exception:
                logger.error("Falha ao carregar qualquer ícone")

    def setup_treeview_bindings(self):
        for tree in [self.process_tree, self.result_tree, self.tela_tree]:
            tree.bind("<Control-a>", self.select_all_treeview)
            tree.bind("<Control-A>", self.select_all_treeview)

    def select_all_treeview(self, event):
        tree = event.widget
        tree.selection_set(tree.get_children())
        return "break"

    # ... (o restante do código permanece igual, exceto pela remoção da função check_for_updates original) ...

# ... (o restante do código permanece inalterado) ...

# Inicialização da aplicação
if __name__ == "__main__":
    root = tk.Tk()
    app = SSHClientGUI(root)
    root.mainloop() 